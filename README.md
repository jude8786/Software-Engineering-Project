üîç Project Objective and Motivation
A) Objective
Develop a small pet project as a way to re-engage with coding. This project, shared on GitHub, will be simple (e.g., a console-based game) and accompanied by concise documentation.

Motivation
I've realized that one of the toughest parts of financial management isn't just adhering to a budget but understanding where my money actually goes. Countless times, I‚Äôve found myself sifting through bank statements, notes, and forgotten receipts to piece together my monthly expenses. This chaotic process made budgeting difficult and often led to overspending without any clear insights.

With this app, I aimed to make financial tracking straightforward, helping myself and others stay organized and on budget. Now, instead of relying on scattered notes and receipts, I can view my finances in a clear, comprehensive way. This project also serves as a tool for others who want to set up their own expense tracking systems and better understand their spending habits.

Traditional methods, like notebooks and spreadsheets, were cumbersome and prone to errors. While there are various budgeting apps available, I wanted to create a customized solution that met my specific needs and provided instant clarity.

üìù Detailed Project Checklist
Below is a checklist addressing each of the points outlined in the learning objectives, with explanations.

1. Use and Understand GIT
Basic Git commands were used throughout the project, including branching, merging, and experimenting with time travel techniques.

2. UML Diagrams
Created at least three different UML diagrams: Use Case, Component, and Class Diagrams, exported for easy viewing.

![Corrected_Simple_Colored_Expense_Tracker_Class_Diagram](https://github.com/user-attachments/assets/995dfb30-9010-47b4-bc77-8ca518d9b9b1)

![Screenshot (186)](https://github.com/user-attachments/assets/b9df1cb9-d0c9-463c-b711-a230b47b6bb9)


3. Requirements Documentation
Developed 5-10 requirements and documented them in tools like Airtable or Notion, with additional integration into a professional tool such as Jira. Mentioned the use of AI/LLMs for assistance.

I. User Authentication:
The app MUST implement user authentication to ensure data security and personalized access.
Users MUST log in to view and manage their expenses.
Authentication SHOULD adhere to best practices for secure data handling.

II. Budget Setting and Management:
Users MUST be able to set a budget, which updates automatically as expenses are added or deleted.
The app MUST display the remaining budget in real-time.
Budget alerts SHOULD notify users when a set budget threshold (e.g., 80%) is reached.

III. Expense Entry and Management:
Users MUST be able to add, edit, and delete expenses with details such as description, amount, category, and date.
Expense data MUST be validated for correctness and completeness before being saved.
Deleting an expense MUST adjust the budget to reflect the updated balance.

IV. Visual Expense Representation:
The app MUST include a bar graph that shows total expenses for each day of the week.
The bar graph MUST update in real-time when expenses are added or edited.
Data visualization SHOULD clearly display expense amounts and labels for each day of the week.

V. Dark/Light Mode Support:
The app MUST provide a toggle option for switching between dark and light themes.
User theme preferences MUST persist across sessions.
The UI SHOULD maintain a consistent, user-friendly experience in both modes.

VI. Expense Categories and Filtering:
Users MUST be able to categorize expenses and filter them by category or date.
The filtering system MUST be efficient and return accurate results.
The app SHOULD enable users to view expenses based on specific filters for better tracking and analysis.


4. Analysis
Created a personalized checklist from the ‚ÄòANA - Analysis‚Äô learning unit and conducted a detailed analysis spanning at least two pages. This included 10-15 key points with brief explanations.

5. Domain-Driven Design (DDD)
Conducted event-storming to discover relevant domains and charted these domains into a Core Domain Chart, illustrating their relationships and mappings.

6. Metrics
Included project metrics such as SonarQube analysis and additional non-trivial metrics.

7. Clean Code Development (CCD)
Demonstrated at least 5 clean code practices in the codebase, with explanations for why they are considered clean. Attached a personal CCD cheat sheet (PDF) with >10 points.

8. Build Management
Employed a build tool (e.g., Maven or Gradle) to automate processes like documentation generation and testing.

9. Continuous Delivery
Implemented a CI/CD pipeline using tools like GitHub Actions, with at least two automated scripts.

10. Unit Tests
Integrated comprehensive unit tests within the codebase.

11. IDE Proficiency
Used a preferred IDE (e.g., VSCode or IntelliJ) and documented the favorite shortcuts and techniques.

12. DSL Implementation
Included a demonstration of a Domain-Specific Language snippet in the project.

13. Functional Programming
Demonstrated the use of functional programming aspects such as side-effect-free functions, closures, and higher-order functions.

üèÜ Bonus
Set up and documented an AI-powered coding environment.

‚ö†Ô∏è Submission Reminder
Ensure all related documents, code snippets, and screenshots are accessible and organized within the README. The project and documentation aim to share personal experiences and practical insights gained during the process.

Submit only a public link to your GitHub repository in Moodle for evaluation. Repositories should remain public until grading is complete, then may be switched to private.
